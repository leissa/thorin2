// RUN: rm -f %t.ll
// RUN: %thorin %s --output-ll %t.ll -o -

.plugin core;
.plugin mem;
.plugin memoir;

.cfun dont_know[mem: %mem.M]: [%mem.M, .Bool];

.let KV    = (.I32, .I64);
.let Assoc = %memoir.Assoc KV;

.fun .extern f(mem: %mem.M, x: .I64): [%mem.M, .I64] =
    // stack-alloc dictionary and init with: 0 -> 23, 1 -> x
    .let (`mem, ptr) = %mem.slot (Assoc, 0) (mem, 0);
    .let `mem        = %mem.store (mem, ptr, %memoir.assoc KV 2 ((0I32, 23I64), (1I32, x)));
    head mem
    .where
        .con head(mem: %mem.M) =
            .ret (`mem, cond) = dont_know $ (mem);
            (exit, body)#cond mem
            .where
                .con body(mem: %mem.M) =
                    .let (`mem, `assoc) = %mem.load (mem, ptr);
                    .let `assoc         = %memoir.write (assoc, 1I32, 42I64); // 1 -> 42
                    .let `mem           = %mem.store (mem, ptr, assoc);
                    .let cond           = %memoir.has (assoc, 1I32);
                    (false, true)#cond mem
                    .where
                        .con true (mem: %mem.M) =
                            .let (`mem, `assoc) = %mem.load (mem, ptr);
                            .let `assoc         = %memoir.write (assoc, 1I32, x); // 1 -> x
                            .let `mem           = %mem.store (mem, ptr, assoc);
                            next mem;

                        .con false(mem: %mem.M) = next mem;
                        .con next (mem: %mem.M) = head mem;
                    .end;

                .con exit(mem: %mem.M) =
                    .let (`mem, `assoc) = %mem.load (mem, ptr);
                    .let val            = %memoir.read (assoc, 1I32);
                    return (mem, val);
            .end
    .end
